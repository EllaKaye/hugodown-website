---
output: hugodown::md_document
# Documentation: https://sourcethemes.com/academic/docs/managing-content/

title: "Advent of Code 2020"
subtitle: ""
summary: "My attempts at [Advent of Code](https://adventofcode.com)."
authors: []
tags: []
categories: []
date: 2020-12-09
lastmod: 2020-12-09
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

[Advent of Code](https://adventofcode.com) is a series of small programming challenges, released daily throughout December in the run-up to Christmas. They are designed to be solved in any programming language. I will be using R. 

There will no doubt be a wide variety of ways of solving these problems. I'm going to go with the first thing I think of that gets an answer. In most cases, I image there will be more efficient solutions.

Each participant gets different input data, so my numerical solutions may be different from others.

1. <a href="#day1">Report repair</a>
2. <a href="#day2">Password philosophy</a>

<p><a id='day1'></a></p>

## Day 1: [Report Repair](https://adventofcode.com/2020/day/1)

The challenge is to find two numbers from a list that sum to 2020, then to report their product.

```{r message = FALSE}
library(dplyr)

expenses <- readLines("AoC_day1.txt") %>%
  as.numeric()

expand.grid(expenses, expenses) %>% 
  mutate(sum = Var1 + Var2) %>%
  filter(sum == 2020) %>%
  mutate(prod = Var1 * Var2) %>%
  slice(1) %>%
  pull(prod)
```

`expand.grid` creates a data frame from all combinations of the supplied vectors. Since the vectors are the same, each pair is duplicated. In this case the two numbers in the list that sum to 2020 are 704 and 1316, and we have one row with 704 as Var1 and one with 704 as Var2. `slice(1)` takes the first occurence of the pair.

The follow-up challenge is the same but with three numbers. I went with essentially the same code but it's notably slower. There are a lot of repeated calculations here: each triplet appears six times in the table.

```{r}
expand.grid(expenses, expenses, expenses) %>% 
  mutate(sum = Var1 + Var2 + Var3) %>%
  filter(sum == 2020) %>%
  mutate(prod = Var1 * Var2 * Var3) %>%
  slice(1) %>%
  pull(prod)
```

<p><a id='day2'></a></p>

## Day 2: [Password philosophy](https://adventofcode.com/2020/day/2)

We need to find how many passwords are valid according to their policy. The policies and passwords are given as follows:

```
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc
```

Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, `1-3 a` means that the password must contain `a` at least 1 time and at most 3 times.

```{r}
library(dplyr)
library(tidyr)
library(stringr)
```

First load the libraries we'll need. We then read in the data and use `tidyr` functions to separate out the parts of the policy and the password:

```{r, message = FALSE}
passwords <- readr::read_tsv("AoC_day2.txt", col_names = FALSE) %>%
  separate(X1, c("policy", "password"), sep = ":") %>%
  separate(policy, c("count", "letter"), sep = " ") %>%
  separate(count, c("min", "max")) %>%
  mutate(min = as.integer(min),
         max = as.integer(max))
```

Next, we use the `stringr` function `str_count` to count how many times the given letter appears in the password, and conditional logic to check whether it is repeated within the specified number of times. Because `TRUE` has a numeric value of 1 and `FALSE` has a numeric value of 0, we can sum the resulting column to get a count of how many passwords are valid according to their policies.

```{r}
passwords %>%
  mutate(count = str_count(password, letter)) %>%
  mutate(password_in_policy = if_else(count >= min & count <= max, TRUE, FALSE)) %>%
  summarise(correct = sum(password_in_policy)) %>%
  pull(correct)
  
```

Part 2 to follow soon...
